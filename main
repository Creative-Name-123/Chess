import pygame
import sys
import io
import requests


# Initialize Pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Chess")

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BROWN_LIGHT = (222, 184, 135)
BROWN_DARK = (139, 69, 19)
GREEN_HIGHLIGHT = (0, 255, 0, 80)  # For highlighting possible moves
DARK_HIGHLIGHT = (0, 50, 0, 200)
RED_HIGHLIGHT = (255, 0, 0, 80)   # For highlighting check (optional for now)

# Board size and square size
BOARD_SIZE = 8
SQUARE_SIZE = SCREEN_WIDTH // BOARD_SIZE // 2

# Piece representation
# 'w' for white, 'b' for black, followed by piece type (R, N, B, Q, K, P)
initial_board = [
    ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
    ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
    ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']]

moves = []

# Create a deep copy of the initial board to start the game
board = [row[:] for row in initial_board]

# Load Piece Images from URLs
piece_images = {}
piece_image_urls = {
    'bR': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Chess_rdt45.svg/45px-Chess_rdt45.svg.png',
    'bN': 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Chess_ndt45.svg/68px-Chess_ndt45.svg.png',
    'bB': 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Chess_bdt45.svg/45px-Chess_bdt45.svg.png',
    'bQ': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/Chess_qdt45.svg/68px-Chess_qdt45.svg.png',
    'bK': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/Chess_kdt45.svg/68px-Chess_kdt45.svg.png',
    'bP': 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/68px-Chess_pdt45.svg.png',
    'wR': 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Chess_rlt45.svg/68px-Chess_rlt45.svg.png',
    'wN': 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Chess_nlt45.svg/68px-Chess_nlt45.svg.png',
    'wB': 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Chess_blt45.svg/68px-Chess_blt45.svg.png',
    'wQ': 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Chess_qlt45.svg/68px-Chess_qlt45.svg.png',
    'wK': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Chess_klt45.svg/68px-Chess_klt45.svg.png',
    'wP': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/68px-Chess_plt45.svg.png'}

# Load and scale images from URLs
headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}

for piece, url in piece_image_urls.items():
    try:
        response = requests.get(url, headers=headers)
        response.raise_for_status()  # Raise an exception for bad status codes (4xx or 5xx)

        # Use io.BytesIO to treat the downloaded data as a file
        image_file = io.BytesIO(response.content)

        image = pygame.image.load(image_file).convert_alpha()
        piece_images[piece] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))

    except requests.exceptions.RequestException as e:
        print(f"Error downloading image from {url}: {e}")
        # Handle download errors (e.g., use a placeholder or skip the piece)
    except pygame.error as e:
        print(f"Error loading image from URL {url}: {e}")
        # Handle Pygame loading errors

# --- Game State Variables ---
current_turn = 'white'
selected_piece_pos = None  # (row, col) of the selected piece
possible_moves = []    # List of (row, col) for possible moves


# --- Helper Functions ---

def get_piece_color(piece):
    """Returns the color ('white' or 'black') of a piece."""
    if piece and piece[0] == 'w':
        return 'white'
    elif piece and piece[0] == 'b':
        return 'black'
    return None


def is_on_board(row, col):
    """Checks if a square is within the board boundaries."""
    return 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE


def is_empty(board, row, col):
    """Checks if a square is empty."""
    return board[row][col] is None


def is_opponent(board, row, col, current_color):
    """Checks if the piece at (row, col) is an opponent's piece."""
    piece = board[row][col]
    if piece:
        piece_color = get_piece_color(piece)
        return piece_color is not None and piece_color != current_color
    return False


# --- Movement Logic for Each Piece Type (Core of the Game) ---

def get_pawn_moves(board, row, col, color):
    moves = []
    direction = -1 if color == 'white' else 1  # -1 for white (up), 1 for black (down)
    start_row = 6 if color == 'white' else 1

    # One step forward
    one_step_row = row + direction
    if is_on_board(one_step_row, col) and is_empty(board, one_step_row, col):
        moves.append((one_step_row, col))

        # Two steps forward from starting position
        two_step_row = row + 2 * direction
        if row == start_row and is_on_board(two_step_row, col) and is_empty(board, two_step_row, col) and is_empty(board, one_step_row, col):
            moves.append((two_step_row, col))

    # Captures
    capture_cols = [col - 1, col + 1]
    for capture_col in capture_cols:
        if is_on_board(one_step_row, capture_col) and is_opponent(board, one_step_row, capture_col, color):
            moves.append((one_step_row, capture_col))

    # TODO: Implement En Passant
    return moves


def get_rook_moves(board, row, col, color):
    moves = []
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up

    for dr, dc in directions:
        r, c = row + dr, col + dc
        while is_on_board(r, c):
            if is_empty(board, r, c):
                moves.append((r, c))
            elif is_opponent(board, r, c, color):
                moves.append((r, c)) # Can capture the opponent
                break # Stop after capturing
            else: # Own piece
                break
            r, c = r + dr, c + dc
    return moves


def get_knight_moves(board, row, col, color):
    moves = []
    knight_moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)]

    for dr, dc in knight_moves:
        r, c = row + dr, col + dc
        if is_on_board(r, c):
            if is_empty(board, r, c) or is_opponent(board, r, c, color):
                moves.append((r, c))
    return moves


def get_bishop_moves(board, row, col, color):
    moves = []
    directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # Diagonals

    for dr, dc in directions:
        r, c = row + dr, col + dc
        while is_on_board(r, c):
            if is_empty(board, r, c):
                moves.append((r, c))
            elif is_opponent(board, r, c, color):
                moves.append((r, c)) # Can capture the opponent
                break # Stop after capturing
            else: # Own piece
                break
            r, c = r + dr, c + dc
    return moves


def get_queen_moves(board, row, col, color):
    # Queen moves are a combination of Rook and Bishop moves
    return get_rook_moves(board, row, col, color) + get_bishop_moves(board, row, col, color)


def get_king_moves(board, row, col, color):
    moves = []
    king_moves = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]

    for dr, dc in king_moves:
        r, c = row + dr, col + dc
        if is_on_board(r, c):
            if is_empty(board, r, c) or is_opponent(board, r, c, color):
                # TODO: Need to check if this move puts the king in check
                moves.append((r, c))

    # TODO: Implement Castling
    return moves


# --- Main Move Calculation Function ---

def get_all_possible_moves(board, row, col):
    """
    Calculates all theoretical moves for the piece at (row, col),
    WITHOUT considering if the move puts the king in check.
    """
    moves = []
    piece = board[row][col]
    if not piece:
        return moves

    color = get_piece_color(piece)
    piece_type = piece[1]

    if piece_type == 'P':
        moves = get_pawn_moves(board, row, col, color)
    elif piece_type == 'R':
        moves = get_rook_moves(board, row, col, color)
    elif piece_type == 'N':
        moves = get_knight_moves(board, row, col, color)
    elif piece_type == 'B':
        moves = get_bishop_moves(board, row, col, color)
    elif piece_type == 'Q':
        moves = get_queen_moves(board, row, col, color)
    elif piece_type == 'K':
        moves = get_king_moves(board, row, col, color)

    # TODO: Filter moves to ensure they don't leave the king in check
    return moves


# --- Game Logic Functions ---

def is_valid_move(board, start_row, start_col, end_row, end_col):
    """
    Checks if a move is valid, including if it's in the list of possible moves
    and if it doesn't leave the player's king in check.
    (Check logic is NOT implemented here yet)
    """
    possible = get_all_possible_moves(board, start_row, start_col)
    if (end_row, end_col) in possible:
        # TODO: Implement check if the move leaves the king in check
        # For now, any move in the possible list is considered valid.
        return True
    return False


def make_move(board, start_row, start_col, end_row, end_col):
    """
    Updates the board state after a valid move.
    """
    piece_to_move = board[start_row][start_col]
    moves.append(piece_to_move + ": " + str(start_col) + ", " + str(start_row) + " to " + str(end_col) + ", " + str(end_row))
    print(moves[-1])
    board[end_row][end_col] = piece_to_move
    board[start_row][start_col] = None
    # TODO: Handle special moves like castling, en passant, and pawn promotion


def switch_turn():
    global current_turn
    current_turn = 'black' if current_turn == 'white' else 'white'


# --- Drawing Functions ---

def draw_board():
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            color = BROWN_LIGHT if (row + col) % 2 == 0 else BROWN_DARK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE + 100, SQUARE_SIZE, SQUARE_SIZE))


def draw_pieces(board, piece_images):
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            piece = board[row][col]
            if piece and piece in piece_images:
                screen.blit(piece_images[piece], (col * SQUARE_SIZE, row * SQUARE_SIZE + 100))
            elif piece:
                 # Fallback if image not loaded
                 font = pygame.font.Font(None, 36)
                 text = font.render(piece, True, WHITE if piece[0] == 'b' else BLACK)
                 text_rect = text.get_rect(center=(col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2))
                 screen.blit(text, text_rect)


def draw_possible_moves(moves):
    for row, col in moves:
        # Draw a semi-transparent green square over possible move destinations
        s = pygame.Surface((SQUARE_SIZE, SQUARE_SIZE), pygame.SRCALPHA)
        if is_empty(board, row, col):
            s.fill(GREEN_HIGHLIGHT)
        else:
            s.fill(DARK_HIGHLIGHT)
        screen.blit(s, (col * SQUARE_SIZE, row * SQUARE_SIZE + 100))


def draw_selected_piece(selected_piece_pos):
    if selected_piece_pos:
        row, col = selected_piece_pos
        # Draw a yellow border around the selected piece
        pygame.draw.rect(screen, (255, 255, 0), (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)


# --- Main Game Loop ---
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            mouse_x, mouse_y = event.pos
            if 0 < mouse_x < SCREEN_WIDTH // 2 and SCREEN_HEIGHT // 2 - 200 < mouse_y < SCREEN_HEIGHT // 2 + 200:
                clicked_row = (mouse_y + 200) // 2 // SQUARE_SIZE
                clicked_col = mouse_x // SQUARE_SIZE

                if selected_piece_pos is None:
                    # No piece selected, try to select one
                    piece_at_click = board[clicked_row][clicked_col]
                    if piece_at_click and get_piece_color(piece_at_click) == current_turn:
                        selected_piece_pos = (clicked_row, clicked_col)
                        possible_moves = get_all_possible_moves(board, clicked_row, clicked_col)
                else:
                    # A piece is selected, try to make a move
                    start_row, start_col = selected_piece_pos
                    end_row, end_col = clicked_row, clicked_col

                    if (end_row, end_col) == selected_piece_pos:
                        # Clicked on the same piece again, deselect
                        selected_piece_pos = None
                        possible_moves = []
                    elif is_valid_move(board, start_row, start_col, end_row, end_col):
                        # Valid move, make it and switch turns
                        make_move(board, start_row, start_col, end_row, end_col)
                        switch_turn()
                        # Reset selection after the move
                        selected_piece_pos = None
                        possible_moves = []
                    else:
                        # Invalid move, deselect the piece
                        selected_piece_pos = None
                        possible_moves = []
            else:
                # Buttons outside the board
                draw_board()


    # Drawing
    screen.fill(DARK_HIGHLIGHT)
    draw_board()
    draw_pieces(board, piece_images)
    draw_possible_moves(possible_moves)
    draw_selected_piece(selected_piece_pos)


    # Update the display
    pygame.display.flip()

# Quit Pygame
pygame.quit()
sys.exit()
