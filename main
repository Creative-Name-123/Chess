import pygame
import sys
import os
import io
import requests

# Initialize Pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 800
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Real Chess Game with Turns")

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
BROWN_LIGHT = (222, 184, 135)
BROWN_DARK = (139, 69, 19)
GREEN_HIGHLIGHT = (0, 255, 0, 80) # For highlighting possible moves
RED_HIGHLIGHT = (255, 0, 0, 80)   # For highlighting check (optional for now)

# Board size and square size
BOARD_SIZE = 8
SQUARE_SIZE = SCREEN_WIDTH // BOARD_SIZE

# Piece representation
# Using a class for pieces could be more organized in a larger project,
# but we'll stick with strings for now for simplicity.
# 'w' for white, 'b' for black, followed by piece type (R, N, B, Q, K, P)
initial_board = [
    ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
    ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
    ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']
]

# Create a deep copy of the initial board to start the game
board = [row[:] for row in initial_board]

# --- Load Piece Images from URLs (Conceptual Outline - NOT directly runnable as is by me) ---
piece_images = {}
# Example URLs (replace with actual URLs for your piece images)
piece_image_urls = {
    'bR': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Chess_rdt45.svg/45px-Chess_rdt45.svg.png',
    'bN': 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Chess_ndt45.svg/45px-Chess_ndt45.svg.png',
    'bB': 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Chess_bdt45.svg/45px-Chess_bdt45.svg.png'
    # ... add URLs for all piece images
}

# Load and scale images from URLs
for piece, url in piece_image_urls.items():
    try:
        response = requests.get(url)
        response.raise_for_status() # Raise an exception for bad status codes (4xx or 5xx)

        # Use io.BytesIO to treat the downloaded data as a file
        image_file = io.BytesIO(response.content)

        image = pygame.image.load(image_file).convert_alpha()
        piece_images[piece] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))

    except requests.exceptions.RequestException as e:
        print(f"Error downloading image from {url}: {e}")
        # Handle download errors (e.g., use a placeholder or skip the piece)
    except pygame.error as e:
        print(f"Error loading image from URL {url}: {e}")
        # Handle Pygame loading errors


# --- Game State Variables ---
current_turn = 'white'
selected_piece_pos = None  # (row, col) of the selected piece
possible_moves = []    # List of (row, col) for possible moves

# --- Helper Functions ---

def get_piece_color(piece):
    """Returns the color ('white' or 'black') of a piece."""
    if piece and piece[0] == 'w':
        return 'white'
    elif piece and piece[0] == 'b':
        return 'black'
    return None

def is_on_board(row, col):
    """Checks if a square is within the board boundaries."""
    return 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE

def is_empty(board, row, col):
    """Checks if a square is empty."""
    return board[row][col] is None

def is_opponent(board, row, col, current_color):
    """Checks if the piece at (row, col) is an opponent's piece."""
    piece = board[row][col]
    if piece:
        piece_color = get_piece_color(piece)
        return piece_color is not None and piece_color != current_color
    return False

# --- Movement Logic for Each Piece Type (Core of the Game) ---

def get_pawn_moves(board, row, col, color):
    moves = []
    direction = -1 if color == 'white' else 1 # -1 for white (up), 1 for black (down)
    start_row = 6 if color == 'white' else 1

    # One step forward
    one_step_row = row + direction
    if is_on_board(one_step_row, col) and is_empty(board, one_step_row, col):
        moves.append((one_step_row, col))

        # Two steps forward from starting position
        two_step_row = row + 2 * direction
        if row == start_row and is_on_board(two_step_row, col) and is_empty(board, two_step_row, col) and is_empty(board, one_step_row, col):
            moves.append((two_step_row, col))

    # Captures
    capture_cols = [col - 1, col + 1]
    for capture_col in capture_cols:
        if is_on_board(one_step_row, capture_col) and is_opponent(board, one_step_row, capture_col, color):
            moves.append((one_step_row, capture_col))

    # TODO: Implement En Passant
    return moves

def get_rook_moves(board, row, col, color):
    moves = []
    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] # Right, Left, Down, Up

    for dr, dc in directions:
        r, c = row + dr, col + dc
        while is_on_board(r, c):
            if is_empty(board, r, c):
                moves.append((r, c))
            elif is_opponent(board, r, c, color):
                moves.append((r, c)) # Can capture the opponent
                break # Stop after capturing
            else: # Own piece
                break
            r, c = r + dr, c + dc
    return moves

def get_knight_moves(board, row, col, color):
    moves = []
    knight_moves = [
        (-2, -1), (-2, 1), (-1, -2), (-1, 2),
        (1, -2), (1, 2), (2, -1), (2, 1)
    ]

    for dr, dc in knight_moves:
        r, c = row + dr, col + dc
        if is_on_board(r, c):
            if is_empty(board, r, c) or is_opponent(board, r, c, color):
                moves.append((r, c))
    return moves

def get_bishop_moves(board, row, col, color):
    moves = []
    directions = [(-1, -1), (-1, 1), (1, -1), (1, 1)] # Diagonals

    for dr, dc in directions:
        r, c = row + dr, col + dc
        while is_on_board(r, c):
            if is_empty(board, r, c):
                moves.append((r, c))
            elif is_opponent(board, r, c, color):
                moves.append((r, c)) # Can capture the opponent
                break # Stop after capturing
            else: # Own piece
                break
            r, c = r + dr, c + dc
    return moves

def get_queen_moves(board, row, col, color):
    # Queen moves are a combination of Rook and Bishop moves
    return get_rook_moves(board, row, col, color) + get_bishop_moves(board, row, col, color)

def get_king_moves(board, row, col, color):
    moves = []
    king_moves = [
        (-1, -1), (-1, 0), (-1, 1),
        (0, -1),           (0, 1),
        (1, -1),  (1, 0),  (1, 1)
    ]

    for dr, dc in king_moves:
        r, c = row + dr, col + dc
        if is_on_board(r, c):
            if is_empty(board, r, c) or is_opponent(board, r, c, color):
                # TODO: Need to check if this move puts the king in check
                moves.append((r, c))

    # TODO: Implement Castling
    return moves

# --- Main Move Calculation Function ---

def get_all_possible_moves(board, row, col):
    """
    Calculates all theoretical moves for the piece at (row, col),
    WITHOUT considering if the move puts the king in check.
    """
    moves = []
    piece = board[row][col]
    if not piece:
        return moves

    color = get_piece_color(piece)
    piece_type = piece[1]

    if piece_type == 'P':
        moves = get_pawn_moves(board, row, col, color)
    elif piece_type == 'R':
        moves = get_rook_moves(board, row, col, color)
    elif piece_type == 'N':
        moves = get_knight_moves(board, row, col, color)
    elif piece_type == 'B':
        moves = get_bishop_moves(board, row, col, color)
    elif piece_type == 'Q':
        moves = get_queen_moves(board, row, col, color)
    elif piece_type == 'K':
        moves = get_king_moves(board, row, col, color)

    # TODO: Filter moves to ensure they don't leave the king in check
    return moves

# --- Game Logic Functions ---

def is_valid_move(board, start_row, start_col, end_row, end_col):
    """
    Checks if a move is valid, including if it's in the list of possible moves
    and if it doesn't leave the player's king in check.
    (Check logic is NOT implemented here yet)
    """
    possible = get_all_possible_moves(board, start_row, start_col)
    if (end_row, end_col) in possible:
        # TODO: Implement check if the move leaves the king in check
        # For now, any move in the possible list is considered valid.
        return True
    return False

def make_move(board, start_row, start_col, end_row, end_col):
    """
    Updates the board state after a valid move.
    """
    piece_to_move = board[start_row][start_col]
    board[end_row][end_col] = piece_to_move
    board[start_row][start_col] = None
    # TODO: Handle special moves like castling, en passant, and pawn promotion

def switch_turn():
    global current_turn
    current_turn = 'black' if current_turn == 'white' else 'white'

# --- Drawing Functions ---

def draw_board():
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            color = BROWN_LIGHT if (row + col) % 2 == 0 else BROWN_DARK
            pygame.draw.rect(screen, color, (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE))

def draw_pieces(board, piece_images):
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            piece = board[row][col]
            if piece and piece in piece_images:
                screen.blit(piece_images[piece], (col * SQUARE_SIZE, row * SQUARE_SIZE))
            elif piece:
                 # Fallback if image not loaded
                 font = pygame.font.Font(None, 36)
                 text = font.render(piece, True, WHITE if piece[0] == 'b' else BLACK)
                 text_rect = text.get_rect(center=(col * SQUARE_SIZE + SQUARE_SIZE // 2, row * SQUARE_SIZE + SQUARE_SIZE // 2))
                 screen.blit(text, text_rect)

def draw_possible_moves(moves):
    for row, col in moves:
        # Draw a semi-transparent green square over possible move destinations
        s = pygame.Surface((SQUARE_SIZE, SQUARE_SIZE), pygame.SRCALPHA)
        s.fill(GREEN_HIGHLIGHT)
        screen.blit(s, (col * SQUARE_SIZE, row * SQUARE_SIZE))

def draw_selected_piece(selected_piece_pos):
    if selected_piece_pos:
        row, col = selected_piece_pos
        # Draw a yellow border around the selected piece
        pygame.draw.rect(screen, (255, 255, 0), (col * SQUARE_SIZE, row * SQUARE_SIZE, SQUARE_SIZE, SQUARE_SIZE), 3)

# --- Main Game Loop ---
running = True
while running:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        elif event.type == pygame.MOUSEBUTTONDOWN:
            mouse_x, mouse_y = event.pos
            clicked_row = mouse_y // SQUARE_SIZE
            clicked_col = mouse_x // SQUARE_SIZE

            if selected_piece_pos is None:
                # No piece selected, try to select one
                piece_at_click = board[clicked_row][clicked_col]
                if piece_at_click and get_piece_color(piece_at_click) == current_turn:
                    selected_piece_pos = (clicked_row, clicked_col)
                    possible_moves = get_all_possible_moves(board, clicked_row, clicked_col)
            else:
                # A piece is selected, try to make a move
                start_row, start_col = selected_piece_pos
                end_row, end_col = clicked_row, clicked_col

                if (end_row, end_col) == selected_piece_pos:
                    # Clicked on the same piece again, deselect
                    selected_piece_pos = None
                    possible_moves = []
                elif is_valid_move(board, start_row, start_col, end_row, end_col):
                    # Valid move, make it and switch turns
                    make_move(board, start_row, start_col, end_row, end_col)
                    switch_turn()
                    # Reset selection after the move
                    selected_piece_pos = None
                    possible_moves = []
                else:
                    # Invalid move, deselect the piece
                    selected_piece_pos = None
                    possible_moves = []


    # Drawing
    screen.fill(BLACK)  # Or another background color
    draw_board()
    draw_pieces(board, piece_images)
    draw_possible_moves(possible_moves)
    draw_selected_piece(selected_piece_pos)


    # Update the display
    pygame.display.flip()

# Quit Pygame
pygame.quit()
sys.exit()
