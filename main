import pygame
import sys
import io
import requests
import math
from datetime import datetime
from tkinter import *

# Initialize Pygame
pygame.init()

# Screen dimensions
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Chess Menu")

# Set up fonts
smallFont = pygame.font.SysFont(None, 20)
font = pygame.font.SysFont(None, 40)
medBigFont = pygame.font.SysFont(None, 70)
bigFont = pygame.font.SysFont(None, 100)
specialChar = pygame.font.SysFont("segoeuisymbol", 15)  # This font is needed to show chess pieces

# Menu Options
menu_options = ["Player vs. Player (offline)", "Player vs. AI", "Options", "Quit"]
selected_option = 0
pvp_starting_time = ["Unlimited", "30", "15", "10", "5", "4", "3", "2", "1"]
pvp_selected_option_1 = 0
pvp_increment = ["15", "10", "5", "4", "3", "2", "1", "0"]
pvp_selected_option_2 = 0
settings_options = ["Load Images for Chess Pieces", "Back"]
settings_selected_option = 0

# Colours
WHITE = (255, 255, 255)
GRAY = (100, 100, 100)
BLACK = (0, 0, 0)
BROWN_LIGHT = (222, 184, 135)
BROWN_DARK = (139, 69, 19)
GREEN_HIGHLIGHT = (0, 255, 0, 80)  # For highlighting possible moves (also for the background)
DARK_HIGHLIGHT = (0, 50, 0, 200)

# Board size and square size
BOARD_SIZE = 8
SQUARE_SIZE = SCREEN_WIDTH // BOARD_SIZE // 2

# Piece representation
initial_board = [
    ['bR', 'bN', 'bB', 'bQ', 'bK', 'bB', 'bN', 'bR'],
    ['bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP', 'bP'],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    [None, None, None, None, None, None, None, None],
    ['wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP', 'wP'],
    ['wR', 'wN', 'wB', 'wQ', 'wK', 'wB', 'wN', 'wR']]

moves = []
real_notation = []

letters = ["a", "b", "c", "d", "e", "f", "g", "h"]
numbers = ["1", "2", "3", "4", "5", "6", "7", "8"]

# Deep copy of initial_board for game state
board = [row[:] for row in initial_board]

# Load Piece Images from URLs
piece_images = {}
piece_image_urls = {
    'bR': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Chess_rdt45.svg/45px-Chess_rdt45.svg.png',
    'bN': 'https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Chess_ndt45.svg/68px-Chess_ndt45.svg.png',
    'bB': 'https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Chess_bdt45.svg/45px-Chess_bdt45.svg.png',
    'bQ': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/Chess_qdt45.svg/68px-Chess_qdt45.svg.png',
    'bK': 'https://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/Chess_kdt45.svg/68px-Chess_kdt45.svg.png',
    'bP': 'https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/68px-Chess_pdt45.svg.png',
    'wR': 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Chess_rlt45.svg/68px-Chess_rlt45.svg.png',
    'wN': 'https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Chess_nlt45.svg/68px-Chess_nlt45.svg.png',
    'wB': 'https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Chess_blt45.svg/68px-Chess_blt45.svg.png',
    'wQ': 'https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Chess_qlt45.svg/68px-Chess_qlt45.svg.png',
    'wK': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Chess_klt45.svg/68px-Chess_klt45.svg.png',
    'wP': 'https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/68px-Chess_plt45.svg.png'
}

headers = {'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)'}


def load_images():
    for piece, url in piece_image_urls.items():
        try:
            response = requests.get(url, headers=headers)
            response.raise_for_status()
            image_file = io.BytesIO(response.content)
            image = pygame.image.load(image_file).convert_alpha()
            piece_images[piece] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
        except requests.exceptions.RequestException as e:
            print(f"Error downloading image from {url}: {e}")
        except pygame.error as e:
            print(f"Error loading image from URL {url}: {e}")


load_images()
current_turn = 'white'
selected_piece_pos = None
possible_moves = []
up = True  # True for normal, False for flipped
epoch = datetime(2008, 6, 8, 3, 15, 8, 596137)
game_start = None
last_move_time = 0
w_move_times = []
b_move_times = []
w_time = 999
b_time = 314159265358979
new_br = "a"
new_bn = "b"
new_bb = "c"
new_bq = "d"
new_bk = "e"
new_bp = "f"
new_wr = "g"
new_wn = "h"
new_wb = ""
new_wq = ""
new_wk = ""
new_wp = ""


# --- Helper Functions ---

def get_piece_colour(piece):
    if piece and piece[0] == 'w':
        return 'white'
    elif piece and piece[0] == 'b':
        return 'black'
    return None


def is_on_board(row, col):
    return 0 <= row < BOARD_SIZE and 0 <= col < BOARD_SIZE


def is_empty(board, row, col):
    return board[row][col] is None


def is_opponent(board, row, col, current_colour):
    piece = board[row][col]
    if piece:
        piece_colour = get_piece_colour(piece)
        return piece_colour is not None and piece_colour != current_colour
    return False


def has_moved(piece_code, start_col=None):
    for move in moves:
        if move.startswith(piece_code):
            if start_col is None or f": {start_col}," in move:
                return True
    return False


def is_square_attacked(board, row, col, by_colour):
    print(f"enemy: {by_colour}")
    enemy = by_colour
    directions = [(-1, -1), (-1, 0), (-1, 1),
                  (0, -1),          (0, 1),
                  (1, -1), (1, 0),  (1, 1)]
    # Pawn attacks
    direction = 1 if enemy == 'w' else -1
    for dc in [-1, 1]:
        r, c = row + direction, col + dc
        if is_on_board(r, c):
            if board[r][c] == enemy + 'P':
                print("pawn attack")
                return True
    # Knight attacks
    knight_moves = [(2, 1), (1, 2), (-1, 2), (-2, 1),
                    (-2, -1), (-1, -2), (1, -2), (2, -1)]
    for dr, dc in knight_moves:
        r, c = row + dr, col + dc
        if is_on_board(r, c):
            if board[r][c] == enemy + 'N':
                print("knight attack")
                return True
    # Sliding pieces
    for dr, dc in directions:
        for i in range(1, 8):
            r, c = row + dr * i, col + dc * i
            if not is_on_board(r, c):
                break
            piece = board[r][c]
            if piece:
                if piece[0] == enemy:
                    p_type = piece[1]
                    if (dr == 0 or dc == 0) and p_type in ('R', 'Q'):
                        print("rook or queen attack")
                        return True
                    elif (dr != 0 and dc != 0) and p_type in ('B', 'Q'):
                        print("rook or queen attack")
                        return True
                break  # Blocked by a piece
    # King attacks
    for dr, dc in directions:
        r, c = row + dr, col + dc
        if is_on_board(r, c):
            if board[r][c] == enemy + 'K':
                print("king attack")
                return True
    print("is_square_attacked() returns False")
    return False


# --- Movement Functions ---

def get_pawn_moves(board, row, col, colour, up):
    moves = []
    # Determine move direction based on flip state
    if up:
        dir = -1 if colour == 'w' else 1
    else:
        dir = 1 if colour == 'w' else -1
    one_step = row + dir
    if is_on_board(one_step, col) and is_empty(board, one_step, col):
        moves.append((one_step, col))
        if colour == "white":
            starting_row = 6
        else:
            starting_row = 1
        if row == starting_row and is_empty(board, one_step + dir, col):
            moves.append((one_step + dir, col))
    # Captures
    for dc in [-1, 1]:
        r, c = row + dir, col + dc
        if is_on_board(r, c) and is_opponent(board, r, c, colour):
            moves.append((r, c))
    return moves


def get_rook_moves(board, row, col, colour):
    moves = []
    for dr, dc in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
        r, c = row + dr, col + dc
        while is_on_board(r, c):
            if is_empty(board, r, c):
                moves.append((r, c))
            elif is_opponent(board, r, c, colour):
                moves.append((r, c))
                break
            else:
                break
            r += dr
            c += dc
    return moves


def get_knight_moves(board, row, col, colour):
    moves = []
    for dr, dc in [(-2,-1), (-2,1), (-1,-2), (-1,2), (1,-2), (1,2), (2,-1), (2,1)]:
        r, c = row + dr, col + dc
        if is_on_board(r, c):
            if is_empty(board, r, c) or is_opponent(board, r, c, colour):
                moves.append((r, c))
    return moves


def get_bishop_moves(board, row, col, colour):
    moves = []
    for dr, dc in [(-1,-1), (-1,1), (1,-1), (1,1)]:
        r, c = row + dr, col + dc
        while is_on_board(r, c):
            if is_empty(board, r, c):
                moves.append((r, c))
            elif is_opponent(board, r, c, colour):
                moves.append((r, c))
                break
            else:
                break
            r += dr
            c += dc
    return moves


def get_queen_moves(board, row, col, colour):
    return get_rook_moves(board, row, col, colour) + get_bishop_moves(board, row, col, colour)


def get_king_moves(board, row, col, colour):
    moves = []
    for dr, dc in [(-1, -1), (-1, 0), (-1, 1),
                   (0, -1),           (0, 1),
                   (1, -1),  (1, 0),  (1, 1)]:
        r, c = row + dr, col + dc
        if is_on_board(r, c):
            if is_empty(board, r, c) or is_opponent(board, r, c, colour):
                moves.append((r, c))
    # Castling
    if not has_moved('wK'):
        # White castling
        if not has_moved('wR') and all(board[7][i] is None for i in [5, 6]):
            moves.append((7, 6))
        if not has_moved('wR') and all(board[7][i] is None for i in [1, 2, 3]):
            moves.append((7, 2))
    if not has_moved('bK'):
        # Black castling
        if not has_moved('bR') and all(board[0][i] is None for i in [5, 6]):
            moves.append((0, 6))
        if not has_moved('bR') and all(board[0][i] is None for i in [1, 2, 3]):
            moves.append((0, 2))
    return moves


def get_all_possible_moves(board, row, col):
    piece = board[row][col]
    if not piece:
        return []
    colour = get_piece_colour(piece)
    p_type = piece[1]
    if p_type == 'P':
        if current_turn == "white":
            return get_pawn_moves(board, row, col, colour, False)
        else:
            return get_pawn_moves(board, row, col, colour, True)
    elif p_type == 'R':
        return get_rook_moves(board, row, col, colour)
    elif p_type == 'N':
        return get_knight_moves(board, row, col, colour)
    elif p_type == 'B':
        return get_bishop_moves(board, row, col, colour)
    elif p_type == 'Q':
        return get_queen_moves(board, row, col, colour)
    elif p_type == 'K':
        return get_king_moves(board, row, col, colour)
    return []


def is_in_check(board, colour):
    # Find the king's position
    king_row, king_col = None, None
    for r in range(8):
        for c in range(8):
            piece = board[r][c]
            if piece == colour[0] + 'K':
                king_row, king_col = r, c
                break
        if king_row is not None:
            break
    if king_row is None:
        # King not found -- should not happen in a valid game
        print("no king?")
        return False
    # Check if the king's position is attacked by opponent
    opponent_colour = 'w' if colour == 'w' else 'b'
    print(f"is_in_check() returns {is_square_attacked(board, king_row, king_col, opponent_colour)}")
    return is_square_attacked(board, king_row, king_col, opponent_colour)


def is_valid_move(board, start_row, start_col, end_row, end_col):
    possible_moves = get_all_possible_moves(board, start_row, start_col)
    if (end_row, end_col) not in possible_moves:
        return False

    # Simulate move
    temp_board = [row[:] for row in board]
    moving_piece = temp_board[start_row][start_col]
    temp_board[end_row][end_col] = moving_piece
    temp_board[start_row][start_col] = None

    current_colour = get_piece_colour(moving_piece)
    in_check = is_in_check(temp_board, current_colour)

    if in_check:
        print("Move leaves king in check. Invalid.")
        return False

    print("Move is valid.")
    return True


# Chess notation is in this function

def make_move(board, start_row, start_col, end_row, end_col, up):
    # Normalize positions if board is flipped
    if not up:
        start_row, start_col = 7 - start_row, 7 - start_col
        end_row, end_col = 7 - end_row, 7 - end_col
    piece = board[start_row][start_col]
    if not piece:
        return
    # Record move
    move_record = f"{piece}: {start_col}, {start_row} to {end_col}, {end_row}"
    moves.append(move_record)
    # Chess Notation
    if current_turn == "white":  # Text characters are different and white's moves start with the move number
        if board[start_row][start_col][1] == "P":
            if not end_row == 0:  # If not pawn promotion
                if board[end_row][end_col] is None:  # If this isn't a capture
                    real_notation.append(str(math.floor(len(moves) / 2) + 1) + ". " + letters[end_col] + numbers[7 - end_row])
                else:
                    real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "R":
            if board[end_row][end_col] is None:
                real_notation.append(str(math.floor(len(moves) / 2) + 1) + ". ♖" + letters[end_col] + numbers[7 - end_row])
            else:
                real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. ♖x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "N":
            if board[end_row][end_col] is None:
                real_notation.append(str(math.floor(len(moves) / 2) + 1) + ". ♘" + letters[end_col] + numbers[7 - end_row])
            else:
                real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. ♘x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "B":
            if board[end_row][end_col] is None:
                real_notation.append(str(math.floor(len(moves) / 2) + 1) + ". ♗" + letters[end_col] + numbers[7 - end_row])
            else:
                real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. ♗x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "Q":
            if board[end_row][end_col] is None:
                real_notation.append(str(math.floor(len(moves) / 2) + 1) + ". ♕" + letters[end_col] + numbers[7 - end_row])
            else:
                real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. ♕x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "K":
            if abs(start_col - end_col) > 1:
                if end_col == 2:
                    real_notation.append(str(math.floor(len(moves) / 2) + 1) + ". O-O-O")
                else:
                    real_notation.append(str(math.floor(len(moves) / 2) + 1) + ". O-O")
            else:
                if board[end_row][end_col] is None:
                    real_notation.append(str(math.floor(len(moves) / 2) + 1) + ". ♔" + letters[end_col] + numbers[7 - end_row])
                else:
                    real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. ♔x{letters[end_col]}{numbers[7 - end_row]}")
    else:
        if board[start_row][start_col][1] == "P":
            if not end_row == 7:
                if board[end_row][end_col] is None:  # If this isn't a capture
                    real_notation.append(letters[end_col] + numbers[7 - end_row])
                else:
                    real_notation.append(f"{letters[start_col]}x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "R":
            if board[end_row][end_col] is None:
                real_notation.append("♜" + letters[end_col] + numbers[7 - end_row])
            else:
                real_notation.append(f"♜x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "N":
            if board[end_row][end_col] is None:
                real_notation.append("♞" + letters[end_col] + numbers[7 - end_row])
            else:
                real_notation.append(f"♞x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "B":
            if board[end_row][end_col] is None:
                real_notation.append("♝" + letters[end_col] + numbers[7 - end_row])
            else:
                real_notation.append(f"♝x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "Q":
            if board[end_row][end_col] is None:
                real_notation.append("♛" + letters[end_col] + numbers[7 - end_row])
            else:
                real_notation.append(f"♛x{letters[end_col]}{numbers[7 - end_row]}")
        elif board[start_row][start_col][1] == "K":
            if abs(start_col - end_col) > 1:
                if end_col == 2:
                    real_notation.append("O-O-O")
                else:
                    real_notation.append("O-O")
            else:
                if board[end_row][end_col] is None:
                    real_notation.append("♚" + letters[end_col] + numbers[7 - end_row])
                else:
                    real_notation.append(f"♔x{letters[end_col]}{numbers[7 - end_row]}")
    # Castling
    if piece[1] == 'K':
        # King side
        if end_col == 6:
            # Move rook
            if piece == 'wK':
                board[7][5] = board[7][7]
                board[7][7] = None
            else:
                board[0][5] = board[0][7]
                board[0][7] = None
        # Queen side
        elif end_col == 2:
            if piece == 'wK':
                board[7][3] = board[7][0]
                board[7][0] = None
            else:
                board[0][3] = board[0][0]
                board[0][0] = None
    # Pawn promotion
    if piece[1] == 'P':
        if (end_row == 0 and piece[0] == 'w') or (end_row == 7 and piece[0] == 'b'):
            board[end_row][end_col] = piece
            board[start_row][start_col] = None
            draw_pieces(board, up)
            global piece_images
            if current_turn == "white":
                pro_piece = ["wQ", "wR", "wB", "wN"]
                for i in range(len(pro_piece)):
                    if pro_piece[i] in piece_images:
                        screen.blit(piece_images[pro_piece[i]], ((3 + i) * SQUARE_SIZE, -SQUARE_SIZE + 100))
                    else:
                        # fallback: draw text
                        font = pygame.font.Font(None, 36)
                        text = font.render(pro_piece[i], True, WHITE)
                        text_rect = text.get_rect(center=((3 + i) * SQUARE_SIZE, -SQUARE_SIZE + 100))
                        screen.blit(text, text_rect)
            else:
                pro_piece = ["bQ", "bR", "bB", "bN"]
                for i in range(len(pro_piece)):
                    if pro_piece[i] in piece_images:
                        screen.blit(piece_images[pro_piece[i]], ((3 + i) * SQUARE_SIZE, -SQUARE_SIZE + 100))
                    else:
                        # fallback: draw text
                        font = pygame.font.Font(None, 36)
                        text = font.render(pro_piece[i], True, BLACK)
                        text_rect = text.get_rect(center=((3 + i) * SQUARE_SIZE, -SQUARE_SIZE + 100))
                        screen.blit(text, text_rect)
            pygame.display.update()
            while True:  # This loop waits for player input (deciding what to promote pawn to) then appends the correct chess notation
                for event in pygame.event.get():
                    if event.type == pygame.MOUSEBUTTONDOWN:
                        mouse_x, mouse_y = event.pos
                        if 50 <= mouse_y <= 100:
                            if 150 <= mouse_x <= 150 + SQUARE_SIZE:
                                board[end_row][end_col] = piece[0] + 'Q'
                                if current_turn == "white":
                                    if board[end_row][end_col] is None:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[end_col]}8=♕")
                                    else:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}8=♕")
                                else:
                                    if board[end_row][end_col] is None:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[end_col]}1=♛")
                                    else:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}1=♛")
                                return
                            if 150 + SQUARE_SIZE <= mouse_x <= 150 + 2 * SQUARE_SIZE:
                                board[end_row][end_col] = piece[0] + 'R'
                                if current_turn == "white":
                                    if board[end_row][end_col] is None:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[end_col]}8=♖")
                                    else:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}8=♖")
                                else:
                                    if board[end_row][end_col] is None:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[end_col]}1=♜")
                                    else:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}1=♜")
                                return
                            if 150 + 2 * SQUARE_SIZE <= mouse_x <= 150 + 3 * SQUARE_SIZE:
                                board[end_row][end_col] = piece[0] + 'B'
                                if current_turn == "white":
                                    if board[end_row][end_col] is None:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[end_col]}8=♗")
                                    else:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}8=♗")
                                else:
                                    if board[end_row][end_col] is None:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[end_col]}1=♝")
                                    else:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}1=♝")
                                return
                            if 150 + 3 * SQUARE_SIZE <= mouse_x <= 150 + 4 * SQUARE_SIZE:
                                board[end_row][end_col] = piece[0] + 'N'
                                if current_turn == "white":
                                    if board[end_row][end_col] is None:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[end_col]}8=♘")
                                    else:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}8=♘")
                                else:
                                    if board[end_row][end_col] is None:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[end_col]}1=♞")
                                    else:
                                        real_notation.append(f"{str(math.floor(len(moves) / 2) + 1)}. {letters[start_col]}x{letters[end_col]}1=♞")
                                return
    # Move the piece
    board[end_row][end_col] = piece
    board[start_row][start_col] = None


def switch_turn():
    global current_turn
    global epoch
    global last_move_time
    global w_move_times
    global b_move_times
    global w_time
    global b_time
    if current_turn == "white":
        w_move_times.append((datetime.now() - epoch).total_seconds() - last_move_time)
        last_move_time = (datetime.now() - epoch).total_seconds()
        w_time = w_time - w_move_times[-1] + int(pvp_increment[pvp_selected_option_2])
        current_turn = "black"
    else:
        b_move_times.append((datetime.now() - epoch).total_seconds() - last_move_time)
        last_move_time = (datetime.now() - epoch).total_seconds()
        b_time = b_time - b_move_times[-1] + int(pvp_increment[pvp_selected_option_2])
        current_turn = "white"


# --- Coordinate Functions ---

def get_display_position(row, col, up):
    if up:
        return row, col
    else:
        return 7 - row, 7 - col


def get_board_position(mouse_x, mouse_y, up):
    col = mouse_x // SQUARE_SIZE
    row = (mouse_y - 100) // SQUARE_SIZE
    if not up:
        return 7 - row, 7 - col
    return row, col


# --- Drawing Functions ---

def draw_board(up):
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            colour = BROWN_LIGHT if (row + col) % 2 == 0 else BROWN_DARK
            x = col * SQUARE_SIZE
            y = row * SQUARE_SIZE + 100
            if not up:
                # When flipped, invert row for drawing
                display_row, display_col = get_display_position(row, col, up)
                x = display_col * SQUARE_SIZE
                y = display_row * SQUARE_SIZE + 100
            pygame.draw.rect(screen, colour, (x, y, SQUARE_SIZE, SQUARE_SIZE))


def draw_pieces(board, up):
    global piece_images
    for row in range(BOARD_SIZE):
        for col in range(BOARD_SIZE):
            piece = board[row][col]
            if piece and piece in piece_images:
                display_row, display_col = get_display_position(row, col, up)
                x = display_col * SQUARE_SIZE
                y = display_row * SQUARE_SIZE + 100
                screen.blit(piece_images[piece], (x, y))
            elif piece:
                # fallback: draw text
                display_row, display_col = get_display_position(row, col, up)
                x = display_col * SQUARE_SIZE + SQUARE_SIZE // 2
                y = display_row * SQUARE_SIZE + 100 + SQUARE_SIZE // 2
                font = pygame.font.Font(None, 36)
                text = font.render(piece, True, WHITE if piece[0] == 'w' else BLACK)
                text_rect = text.get_rect(center=(x, y))
                screen.blit(text, text_rect)


def draw_possible_moves(possible_moves, up):
    for row, col in possible_moves:
        display_row, display_col = get_display_position(row, col, up)
        x = display_col * SQUARE_SIZE
        y = display_row * SQUARE_SIZE + 100
        s = pygame.Surface((SQUARE_SIZE, SQUARE_SIZE), pygame.SRCALPHA)
        s.fill(GREEN_HIGHLIGHT)
        screen.blit(s, (x, y))


def draw_selected_piece(selected_piece_pos, up):
    if selected_piece_pos:
        row, col = selected_piece_pos
        display_row, display_col = get_display_position(row, col, up)
        x = display_col * SQUARE_SIZE
        y = display_row * SQUARE_SIZE + 100
        pygame.draw.rect(screen, (255, 255, 0), (x, y, SQUARE_SIZE, SQUARE_SIZE), 3)


# --- Main Loop for the menu and the game ---

def draw_menu():
    screen.fill(BLACK)
    for i, option in enumerate(menu_options):
        if i == selected_option:
            color = GRAY
        else:
            color = WHITE
        text = font.render(option, True, color)
        rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + i * 50))
        screen.blit(text, rect)
    text = bigFont.render("Chess", True, GREEN_HIGHLIGHT)
    rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 100))
    screen.blit(text, rect)
    pygame.display.flip()


def draw_pvp_menu_1():
    screen.fill(BLACK)
    for i, option in enumerate(pvp_starting_time):
        if i == pvp_selected_option_1:
            color = GRAY
        else:
            color = WHITE
        text = font.render(option, True, color)
        rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50 + i * 33))
        screen.blit(text, rect)
    text = medBigFont.render("Time Settings", True, GREEN_HIGHLIGHT)
    rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 175))
    screen.blit(text, rect)
    text = medBigFont.render("(starting time)", True, GREEN_HIGHLIGHT)
    rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 100))
    screen.blit(text, rect)
    pygame.display.flip()


def draw_pvp_menu_2():
    screen.fill(BLACK)
    for i, option in enumerate(pvp_increment):
        if i == pvp_selected_option_2:
            color = GRAY
        else:
            color = WHITE
        text = font.render(option, True, color)
        rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50 + i * 33))
        screen.blit(text, rect)
    text = medBigFont.render("Time Settings", True, GREEN_HIGHLIGHT)
    rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 175))
    screen.blit(text, rect)
    text = medBigFont.render("(time increment every move)", True, GREEN_HIGHLIGHT)
    rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 100))
    screen.blit(text, rect)
    pygame.display.flip()


def draw_options_menu():
    screen.fill(BLACK)
    for i, option in enumerate(settings_options):
        if i == settings_selected_option:
            color = GRAY
        else:
            color = WHITE
        text = font.render(option, True, color)
        rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + i * 50))
        screen.blit(text, rect)
    text = bigFont.render("Chess", True, GREEN_HIGHLIGHT)
    rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 100))
    screen.blit(text, rect)
    pygame.display.flip()


def main():
    menu_screen = 0
    global selected_option
    global pvp_selected_option_1
    global pvp_selected_option_2
    global settings_selected_option
    clock = pygame.time.Clock()
    while True:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_UP:
                    if menu_screen == 0:
                        selected_option = (selected_option - 1) % len(menu_options)
                    elif menu_screen == 1:
                        pvp_selected_option_1 = (pvp_selected_option_1 - 1) % len(pvp_starting_time)
                    elif menu_screen == 2:
                        pvp_selected_option_2 = (pvp_selected_option_2 - 1) % len(pvp_starting_time)
                    elif menu_screen == -1:
                        settings_selected_option = (settings_selected_option - 1) % len(settings_options)
                elif event.key == pygame.K_DOWN:
                    if menu_screen == 0:
                        selected_option = (selected_option + 1) % len(menu_options)
                    elif menu_screen == 1:
                        pvp_selected_option_1 = (pvp_selected_option_1 + 1) % len(pvp_starting_time)
                    elif menu_screen == 2:
                        pvp_selected_option_2 = (pvp_selected_option_2 + 1) % len(pvp_starting_time)
                    elif menu_screen == -1:
                        settings_selected_option = (settings_selected_option + 1) % len(settings_options)
                elif event.key == pygame.K_RETURN:
                    # Menu selection
                    if menu_screen == 0:
                        if menu_options[selected_option].startswith("Player vs. Player"):
                            menu_screen = 1
                        elif menu_options[selected_option] == "Player vs. AI":
                            chess_game()
                        elif menu_options[selected_option] == "Options":
                            menu_screen = -1
                        elif menu_options[selected_option] == "Quit":
                            pygame.quit()
                            sys.exit()
                    elif menu_screen == 1:
                        if pvp_starting_time[pvp_selected_option_1] == "Unlimited":  # If there is unlimited time, there is no need for time increments
                            chess_game()
                        else:
                            menu_screen = 2
                    elif menu_screen == 2:
                        chess_game()
                    elif menu_screen == -1:
                        if settings_options[settings_selected_option] == "Back":
                            menu_screen = 0
                        elif settings_options[settings_selected_option] == "Load Images for Chess Pieces":
                            root = Tk()
                            root.geometry("300x450")
                            root.title("Import Images")
                            wp_text = Label(root, text="White Pawn:")
                            wp_text.place(x=30, y=10)
                            wp = Entry(root, width=20, bg="light yellow")
                            wp.place(x=110, y=10)
                            wr_text = Label(root, text="White Rook:")
                            wr_text.place(x=30, y=30)
                            wr = Entry(root, width=20, bg="light yellow")
                            wr.place(x=110, y=30)
                            wn_text = Label(root, text="White Knight:")
                            wn_text.place(x=30, y=50)
                            wn = Entry(root, width=20, bg="light yellow")
                            wn.place(x=110, y=50)
                            wb_text = Label(root, text="White Bishop:")
                            wb_text.place(x=30, y=70)
                            wb = Entry(root, width=20, bg="light yellow")
                            wb.place(x=110, y=70)
                            wq_text = Label(root, text="White Queen:")
                            wq_text.place(x=30, y=90)
                            wq = Entry(root, width=20, bg="light yellow")
                            wq.place(x=110, y=90)
                            wk_text = Label(root, text="White King:")
                            wk_text.place(x=30, y=110)
                            wk = Entry(root, width=20, bg="light yellow")
                            wk.place(x=110, y=110)
                            bp_text = Label(root, text="Black Pawn:")
                            bp_text.place(x=30, y=150)
                            bp = Entry(root, width=20, bg="light yellow")
                            bp.place(x=110, y=150)
                            br_text = Label(root, text="Black Rook:")
                            br_text.place(x=30, y=170)
                            br = Entry(root, width=20, bg="light yellow")
                            br.place(x=110, y=170)
                            bn_text = Label(root, text="Black Knight:")
                            bn_text.place(x=30, y=190)
                            bn = Entry(root, width=20, bg="light yellow")
                            bn.place(x=110, y=190)
                            bb_text = Label(root, text="Black Bishop:")
                            bb_text.place(x=30, y=210)
                            bb = Entry(root, width=20, bg="light yellow")
                            bb.place(x=110, y=210)
                            bq_text = Label(root, text="Black Queen:")
                            bq_text.place(x=30, y=230)
                            bq = Entry(root, width=20, bg="light yellow")
                            bq.place(x=110, y=230)
                            bk_text = Label(root, text="Black King:")
                            bk_text.place(x=30, y=250)
                            bk = Entry(root, width=20, bg="light yellow")
                            bk.place(x=110, y=250)
                            info1 = Label(root, text="Pictures must be .jpg or .png and might")
                            info1.place(x=40, y=300)
                            info2 = Label(root, text="have to be from the Wikimedia website")
                            info2.place(x=40, y=320)

                            def close():
                                global new_br
                                global new_bn
                                global new_bb
                                global new_bq
                                global new_bk
                                global new_bp
                                global new_wr
                                global new_wn
                                global new_wb
                                global new_wq
                                global new_wk
                                global new_wp
                                new_br = br.get()
                                new_bn = bn.get()
                                new_bb = bb.get()
                                new_bq = bq.get()
                                new_bk = bk.get()
                                new_bp = bp.get()
                                new_wr = wr.get()
                                new_wn = wn.get()
                                new_wb = wb.get()
                                new_wq = wq.get()
                                new_wk = wk.get()
                                new_wp = wp.get()
                                root.destroy()

                            save_button = Button(root, text="Save", command=close)
                            save_button.place(x=145, y=400)

                            root.mainloop()
                            # Update images
                            global piece_image_urls
                            global new_br
                            global new_bn
                            global new_bb
                            global new_bq
                            global new_bk
                            global new_bp
                            global new_wr
                            global new_wn
                            global new_wb
                            global new_wq
                            global new_wk
                            global new_wp
                            if len(new_br) > 0:
                                try:
                                    response = requests.get(new_br, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['bR'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the black rook image")
                                else:
                                    piece_image_urls['bR'] = br
                            if len(new_bn) > 0:
                                try:
                                    response = requests.get(new_bn, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['bN'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the black knight image")
                                else:
                                    piece_image_urls['bN'] = bn
                            if len(new_bb) > 0:
                                try:
                                    response = requests.get(new_bb, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['bB'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the black bishop image")
                                else:
                                    piece_image_urls['bB'] = bb
                            if len(new_bq) > 0:
                                try:
                                    response = requests.get(new_bq, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['bQ'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the black queen image")
                                else:
                                    piece_image_urls['bQ'] = bq
                            if len(new_bk) > 0:
                                try:
                                    response = requests.get(new_bk, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['bK'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the black king image")
                                else:
                                    piece_image_urls['bK'] = bk
                            if len(new_bp) > 0:
                                try:
                                    response = requests.get(new_bp, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['bP'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the black pawn image")
                                else:
                                    piece_image_urls['bP'] = bp
                            if len(new_wr) > 0:
                                try:
                                    response = requests.get(new_wr, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['wR'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the white rook image")
                                else:
                                    piece_image_urls['wR'] = wr
                            if len(new_wn) > 0:
                                try:
                                    response = requests.get(new_wn, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['wN'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the white knight image")
                                else:
                                    piece_image_urls['wN'] = wn
                            if len(new_wb) > 0:
                                try:
                                    response = requests.get(new_wb, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['wB'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the white bishop image")
                                else:
                                    piece_image_urls['wB'] = wb
                            if len(new_wq) > 0:
                                try:
                                    response = requests.get(new_wq, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['wQ'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the white queen image")
                                else:
                                    piece_image_urls['wQ'] = wq
                            if len(new_wk) > 0:
                                try:
                                    response = requests.get(new_wk, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['wK'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the white king image")
                                else:
                                    piece_image_urls['wK'] = wk
                            if len(new_wp) > 0:
                                try:
                                    response = requests.get(new_wp, headers=headers)
                                    response.raise_for_status()
                                    image_file = io.BytesIO(response.content)
                                    image = pygame.image.load(image_file).convert_alpha()
                                    piece_images['wP'] = pygame.transform.scale(image, (SQUARE_SIZE, SQUARE_SIZE))
                                except Exception as e:
                                    print("Error with the white pawn image")
                                else:
                                    piece_image_urls['wP'] = new_wp
                            load_images()
        if menu_screen == 0:
            draw_menu()
        elif menu_screen == -1:
            draw_options_menu()
        elif menu_screen == 1:
            draw_pvp_menu_1()
        elif menu_screen == 2:
            draw_pvp_menu_2()
        clock.tick(60)  # Max FPS


def chess_game():
    global epoch
    global game_start
    global last_move_time
    global w_move_times
    global b_move_times
    global w_time
    global b_time
    if not game_start:
        game_start = datetime.now()  # In format 2025-05-31 10:04:28.449960
        last_move_time = (game_start - epoch).total_seconds()  # Seconds between 0th birthday and game start (float)
    global up
    global SCREEN_HEIGHT
    global SCREEN_WIDTH
    global selected_piece_pos
    global possible_moves
    global menu_options
    global selected_option
    if not pvp_starting_time[pvp_selected_option_1] == "Unlimited":
        w_time = int(pvp_starting_time[pvp_selected_option_1]) * 60
        b_time = int(pvp_starting_time[pvp_selected_option_1]) * 60
    else:
        w_time = 10 ** 100
        b_time = 10 ** 100
    running = True
    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:  # When the 'f' key is pressed
                if event.key == pygame.K_f:
                    # Toggle flip
                    up = not up
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_x, mouse_y = event.pos
                if 100 < mouse_y < 100 + BOARD_SIZE * SQUARE_SIZE and mouse_x < BOARD_SIZE * SQUARE_SIZE:
                    clicked_row, clicked_col = get_board_position(mouse_x, mouse_y, up)
                    if selected_piece_pos is None:
                        # Select a piece
                        piece_at_click = board[clicked_row][clicked_col]
                        if piece_at_click and get_piece_colour(piece_at_click) == current_turn:
                            selected_piece_pos = (clicked_row, clicked_col)
                            possible_moves = get_all_possible_moves(board, clicked_row, clicked_col)
                    else:
                        # Make move
                        start_row, start_col = selected_piece_pos
                        if not up:
                            start_row, start_col = 7 - start_row, 7 - start_col
                            end_row, end_col = 7 - clicked_row, 7 - clicked_col
                        else:
                            end_row, end_col = clicked_row, clicked_col
                        if is_valid_move(board, start_row, start_col, end_row, end_col):
                            make_move(board, start_row, start_col, end_row, end_col, up)
                            switch_turn()
                        else:
                            print("no")
                        # Deselect after move attempt
                        selected_piece_pos = None
                        possible_moves = []
        # Drawing
        screen.fill(DARK_HIGHLIGHT)
        draw_board(up)
        draw_pieces(board, up)
        draw_possible_moves(possible_moves, up)
        draw_selected_piece(selected_piece_pos, up)
        pygame.draw.rect(screen, GRAY, (475, 100, SQUARE_SIZE * 5, SQUARE_SIZE * BOARD_SIZE))  # Gray rectangle
        if pvp_starting_time[pvp_selected_option_1] == "Unlimited":
            text = specialChar.render("Unlimited Time Chess", True, WHITE)
        elif pvp_increment[pvp_selected_option_2] == "0":
            text = specialChar.render(f"{pvp_starting_time[pvp_selected_option_1]} Minute Chess", True, WHITE)
        else:
            text = specialChar.render(f"{pvp_starting_time[pvp_selected_option_1]} | {pvp_increment[pvp_selected_option_2]} Chess", True, WHITE)
        rect = text.get_rect(midleft=(SCREEN_WIDTH // 2 + 80, SCREEN_HEIGHT // 2 - 210))
        screen.blit(text, rect)
        if current_turn == "white":
            w_live_time = w_time - ((datetime.now() - epoch).total_seconds() - last_move_time)
            b_live_time = b_time
        else:
            b_live_time = b_time - ((datetime.now() - epoch).total_seconds() - last_move_time)
            w_live_time = w_time
        if not pvp_starting_time[pvp_selected_option_1] == "Unlimited":
            text = font.render(f"{math.floor(w_live_time / 60):02d}:{round((w_live_time - math.floor(w_live_time / 60) * 60) * 10) / 10:04.1f}", True, WHITE)
            rect = text.get_rect(midleft=(25, SCREEN_HEIGHT // 2 + 225))
            screen.blit(text, rect)
            text = font.render(f"{math.floor(b_live_time / 60):02d}:{round((b_live_time - math.floor(b_live_time / 60) * 60) * 10) / 10:04.1f}", True, WHITE)
            rect = text.get_rect(midleft=(25, SCREEN_HEIGHT // 2 - 225))
            screen.blit(text, rect)
        text = specialChar.render("Moves:", True, WHITE)
        rect = text.get_rect(midleft=(SCREEN_WIDTH // 2 + 95, SCREEN_HEIGHT // 2 - 175))
        screen.blit(text, rect)
        for i in range(len(moves)):
            text = specialChar.render(f"{real_notation[i]}", True, WHITE)
            if ".5" in str(i / 2):
                rect = text.get_rect(midleft=(SCREEN_WIDTH // 2 + 185, SCREEN_HEIGHT // 2 - 160 + math.floor(i // 2) * 15))
            else:
                rect = text.get_rect(midleft=(SCREEN_WIDTH // 2 + 95, SCREEN_HEIGHT // 2 - 160 + math.floor(i // 2) * 15))
            screen.blit(text, rect)
        for i in range(8):
            if (".5" in str(i / 2) and up) or (not ".5" in str(i / 2) and not up):
                text = specialChar.render(letters[i], True, BROWN_DARK)
            else:
                text = specialChar.render(letters[i], True, BROWN_LIGHT)
            if up:
                rect = text.get_rect(midleft=(-6 + SQUARE_SIZE * (i + 1), SCREEN_HEIGHT // 2 + 192))
            else:
                rect = text.get_rect(midleft=(-6 + SQUARE_SIZE * (7 - i + 1), SCREEN_HEIGHT // 2 + 192))
            screen.blit(text, rect)
            if (".5" in str(i / 2) and up) or (not ".5" in str(i / 2) and not up):
                text = specialChar.render(numbers[i], True, BROWN_DARK)
            else:
                text = specialChar.render(numbers[i], True, BROWN_LIGHT)
            if up:
                rect = text.get_rect(midleft=(5, SCREEN_HEIGHT // 2 + 207 - SQUARE_SIZE * (i + 1)))
            else:
                rect = text.get_rect(midleft=(5, SCREEN_HEIGHT // 2 + 207 - SQUARE_SIZE * (7 - i + 1)))
            screen.blit(text, rect)
        pygame.display.flip()


main()  # Starts game

pygame.quit()
sys.exit()
